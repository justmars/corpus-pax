{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"corpus-pax Docs","text":"<p>Using a sqlpyd-fashioned database, create tables for generic users, organizations, and articles, sourcing the data from Github repositories.</p> <pre><code>flowchart TB\nsubgraph dev env\n  pax[corpus-pax]\n  pax--run setup_pax---&gt;db[(sqlite.db)]\nend\nsubgraph /corpus-entities\n  1(members)--github api---pax\n  2(orgs)--github api---pax\nend\nsubgraph /lawsql-articles\n  3(articles)--github api---pax\nend\npax--cloudflare api--&gt;cf(cloudflare images)</code></pre> <p>Each corpus entity in the <code>/corpus-entities</code> repository will contain 2 files: a <code>details.yaml</code> and an <code>avatar.jpeg</code> organized according to the following structure:</p> YAML<pre><code>/&lt;gh-repo&gt; # github repository\n/members\n/&lt;id-of-individual-1&gt;\n- details.yaml\n- avatar.jpeg\n/orgs\n/&lt;id-of-org-1&gt;\n- details.yaml\n- avatar.jpeg\n</code></pre> <p>The <code>details.yaml</code> file should contain the key value pairs for the org represented by the id.</p>"},{"location":"#rationale","title":"Rationale","text":""},{"location":"#why-github","title":"Why Github","text":"<p>The names and profiles of individuals and organizations are stored in Github. These are pulled into the application via an API call requiring the use of a personal access token.</p>"},{"location":"#why-cloudflare-images","title":"Why Cloudflare Images","text":"<p>Individuals and organizations have images stored in Github. To persist and optimize images for the web, I use Cloudflare Images to take advantage of modern image formats and customizable variants.</p>"},{"location":"#why-sqlite","title":"Why sqlite","text":"<p>The initial data is simple. This database however will be the foundation for a more complicated schema. Sqlite seems a better fit for experimentation and future app use (Android and iOS rely on sqlite).</p>"},{"location":"#run","title":"Run","text":"Python<pre><code>&gt;&gt;&gt; from corpus_pax import setup_pax\n&gt;&gt;&gt; setup_pax(\"x.db\")\n</code></pre> <p>Since it's hard to correct the m2m tables, <code>setup_pax()</code> drops all the tables first, before adding content.</p> <p><code>setup_pax()</code> is a collection of 3 functions:</p>"},{"location":"#add-individuals","title":"Add individuals","text":"<p>Add/replace records of individuals from an API call.</p> Source code in <code>corpus_pax/__main__.py</code> Python<pre><code>def add_individuals_from_api(c: Connection, replace_img: bool = False):\n\"\"\"Add/replace records of individuals from an API call.\"\"\"\nfor entity_individual in Individual.list_members_repo():\nIndividual.make_or_replace(c, entity_individual[\"url\"], replace_img)\n</code></pre>"},{"location":"#add-organizations","title":"Add organizations","text":"<p>Add/replace records of organizations from an API call.</p> Source code in <code>corpus_pax/__main__.py</code> Python<pre><code>def add_organizations_from_api(c: Connection, replace_img: bool = False):\n\"\"\"Add/replace records of organizations from an API call.\"\"\"\nfor entity_org in Org.list_orgs_repo():\nOrg.make_or_replace(c, entity_org[\"url\"], replace_img)\n</code></pre>"},{"location":"#add-articles","title":"Add articles","text":"<p>Add/replace records of articles from an API call.</p> Source code in <code>corpus_pax/__main__.py</code> Python<pre><code>def add_articles_from_api(c: Connection):\n\"\"\"Add/replace records of articles from an API call.\"\"\"\nfor extracted_data in Article.extract_articles():\nArticle.make_or_replace(c, extracted_data)\n</code></pre>"},{"location":"#prerequisites","title":"Prerequisites","text":""},{"location":"#repositories","title":"Repositories","text":"<p>Different repositories involved:</p> repository status type purpose lawsql-articles private data source used by corpus-pax; yaml-formatted member and org files corpus-entities private data source used by corpus-pax; markdown-styled articles with frontmatter corpus-pax public sqlite i/o functions to create pax-related tables <p>Since data concerning members will be pulled from such repositories, make sure the individual / org fields in resources match the data pulled from <code>corpus-entities</code>.</p> <p>Each avatar image should be named <code>avatar.jpeg</code> so that these can be uploaded to Cloudflare.</p>"},{"location":"#env","title":".env","text":"<p>Create an .env file to create/populate the database. See <code>sample .env</code> highlighting the following variables:</p> <ol> <li>Cloudflare <code>CF_ACCT</code></li> <li>Cloudflare <code>CF_TOKEN</code></li> <li>Github <code>GH_TOKEN</code></li> <li><code>DB_FILE</code> (sqlite)</li> </ol> <p>Note the workflow (main.yml) where the secrets are included for Github actions. Ensure these are set in the repository's <code>&lt;url-to-repo&gt;/settings/secrets/actions</code>, making the proper replacements when the tokens for Cloudflare and Github expire.</p>"},{"location":"#articles","title":"Articles","text":"<p>         Bases: <code>TableConfig</code></p> Source code in <code>corpus_pax/articles.py</code> Python<pre><code>class Article(TableConfig):\n__prefix__ = \"pax\"\n__tablename__ = \"articles\"\nurl: HttpUrl = Field(col=str)\nid: str = Field(col=str)\ntitle: str = Field(col=str, fts=True)\ndescription: str = Field(col=str, fts=True)\ndate: datetime.date = Field(..., col=datetime.date, index=True)\ncreated: float = Field(col=float)\nmodified: float = Field(col=float)\ncontent: str = Field(col=str, fts=True)\ntags: list[str] = Field(\ndefault_factory=list,\ntitle=\"Subject Matter\",\ndescription=\"Itemized strings, referring to the topic tag involved.\",\nexclude=True,\n)\nauthors: list[EmailStr] = Field(default_factory=list, exclude=True)\n@classmethod\ndef extract_articles(cls):\n\"\"\"Based on entries from a Github folder, ignore files\n        not formatted in .md and extract the Pydantic-model;\n        the model is based on the frontmatter metadata of each\n        markdown article.\n        \"\"\"\narticles = []\nfor entry in gh.fetch_articles():\nif fn := entry.get(\"name\"):\nif fn.endswith(\".md\"):\nif url := entry.get(\"url\"):\nid = fn.removesuffix(\".md\")\nmodified = gh.fetch_article_date_modified(fn)\ndetails = cls.extract_markdown_postmatter(url)\narticle = cls(id=id, modified=modified, **details)\narticles.append(article)\nreturn articles\n@classmethod\ndef extract_markdown_postmatter(cls, url: str) -&gt; dict:\n\"\"\"Convert the markdown/frontmatter file fetched via url to a dict.\"\"\"\nmdfile = gh.fetch(url)\npost = frontmatter.loads(mdfile.content)\nd = parser.parse(post[\"date\"]).astimezone(ZoneInfo(\"Asia/Manila\"))\nreturn {\n\"url\": url,\n\"created\": d.timestamp(),\n\"date\": d.date(),\n\"title\": post[\"title\"],\n\"description\": post[\"summary\"],\n\"content\": post.content,\n\"authors\": post[\"authors\"],\n\"tags\": post[\"tags\"],\n}\n@classmethod\ndef make_or_replace(cls, c: Connection, extract: Any):\ntbl = c.table(cls)\nrow = tbl.insert(extract.dict(), replace=True, pk=\"id\")  # type: ignore\nif row.last_pk:\nfor author_email in extract.authors:\ntbl.update(row.last_pk).m2m(\nother_table=Individual.__tablename__,\nlookup={\"email\": author_email},\npk=\"id\",\n)\nfor tag in extract.tags:\ntbl.update(row.last_pk).m2m(\nother_table=Tag.__tablename__,\nlookup=Tag(**{\"tag\": tag}).dict(),\n)\n</code></pre>"},{"location":"#corpus_pax.articles.Article-functions","title":"Functions","text":""},{"location":"#corpus_pax.articles.Article.extract_articles","title":"<code>extract_articles()</code>  <code>classmethod</code>","text":"<p>Based on entries from a Github folder, ignore files not formatted in .md and extract the Pydantic-model; the model is based on the frontmatter metadata of each markdown article.</p> Source code in <code>corpus_pax/articles.py</code> Python<pre><code>@classmethod\ndef extract_articles(cls):\n\"\"\"Based on entries from a Github folder, ignore files\n    not formatted in .md and extract the Pydantic-model;\n    the model is based on the frontmatter metadata of each\n    markdown article.\n    \"\"\"\narticles = []\nfor entry in gh.fetch_articles():\nif fn := entry.get(\"name\"):\nif fn.endswith(\".md\"):\nif url := entry.get(\"url\"):\nid = fn.removesuffix(\".md\")\nmodified = gh.fetch_article_date_modified(fn)\ndetails = cls.extract_markdown_postmatter(url)\narticle = cls(id=id, modified=modified, **details)\narticles.append(article)\nreturn articles\n</code></pre>"},{"location":"#corpus_pax.articles.Article.extract_markdown_postmatter","title":"<code>extract_markdown_postmatter(url)</code>  <code>classmethod</code>","text":"<p>Convert the markdown/frontmatter file fetched via url to a dict.</p> Source code in <code>corpus_pax/articles.py</code> Python<pre><code>@classmethod\ndef extract_markdown_postmatter(cls, url: str) -&gt; dict:\n\"\"\"Convert the markdown/frontmatter file fetched via url to a dict.\"\"\"\nmdfile = gh.fetch(url)\npost = frontmatter.loads(mdfile.content)\nd = parser.parse(post[\"date\"]).astimezone(ZoneInfo(\"Asia/Manila\"))\nreturn {\n\"url\": url,\n\"created\": d.timestamp(),\n\"date\": d.date(),\n\"title\": post[\"title\"],\n\"description\": post[\"summary\"],\n\"content\": post.content,\n\"authors\": post[\"authors\"],\n\"tags\": post[\"tags\"],\n}\n</code></pre>"},{"location":"#entities","title":"Entities","text":""},{"location":"#registeredmember","title":"RegisteredMember","text":"<p>         Bases: <code>BaseModel</code></p> <p>Common validator for corpus entities: Individuals and Orgs. Note that the <code>col</code> attribute is for use in <code>sqlpyd</code>.</p> Source code in <code>corpus_pax/resources.py</code> Python<pre><code>class RegisteredMember(BaseModel):\n\"\"\"Common validator for corpus entities: Individuals and Orgs.\n    Note that the `col` attribute is for use in `sqlpyd`.\"\"\"\nid: str = Field(col=str)\ncreated: float = Field(col=float)\nmodified: float = Field(col=float)\nsearch_rank: RankStatus | None = Field(\nRankStatus.Ordinary,\ntitle=\"Search Rank\",\ndescription=\"Can use as a means to determine rank in SERP\",\ncol=int,\n)\nemail: EmailStr = Field(col=str)\nimg_id: str | None = Field(\nNone,\ntitle=\"Cloudflare Image ID\",\ndescription=(\n\"Based on email, upload a unique avatar that can be called via\"\n\" Cloudflare Images.\"\n),\ncol=str,\n)\ndisplay_url: HttpUrl | None = Field(\ntitle=\"Associated URL\",\ndescription=(\n\"When visiting the profile of the member, what URL is associated\"\n\" with the latter?\"\n),\ncol=str,\n)\ndisplay_name: str = Field(\n...,\ntitle=\"Display Name\",\ndescription=\"Preferred way of being designated in the platform.\",\nmin_length=5,\ncol=str,\nfts=True,\n)\ncaption: str | None = Field(\nNone,\ndescription=(\n\"For individuals, the way by which a person is to be known, e.g.\"\n\" Lawyer and Programmer; if an organization, it's motto or quote,\"\n\" i.e. 'just do it'.\"\n),\ncol=str,\n)\ndescription: str | None = Field(\nNone,\ntitle=\"Member Description\",\ndescription=(\n\"Useful for both SEO and for contextualizing the profile object.\"\n),\nmin_length=10,\ncol=str,\nfts=True,\n)\ntwitter: str | None = Field(None, title=\"Twitter username\", col=str)\ngithub: str | None = Field(None, title=\"Github username\", col=str)\nlinkedin: str | None = Field(None, title=\"LinkedIn username\", col=str)\nfacebook: str | None = Field(None, title=\"Facebook page\", col=str)\nareas: list[str] | None = Field(\ndefault_factory=list,\ntitle=\"Practice Areas\",\ndescription=(\n\"Itemized strings, referring to specialization of both natural and\"\n\" artificial persons, that will be mapped to a unique table\"\n),\nexclude=True,\n)\ncategories: list[str] | None = Field(\ndefault_factory=list,\ntitle=\"Entity Categories\",\ndescription=(\n\"Itemized strings, referring to type of entity of both natural\"\n\" (e.g. lawyer) and artificial (e.g. law firm) persons, that will\"\n\" be mapped to a unique table\"\n),\nexclude=True,\n)\nmembers: list[dict[str, int | str | EmailStr]] | None = Field(\ndefault_factory=list, exclude=True\n)\nclass Config:\nuse_enum_values = True\n@classmethod\ndef extract_details(cls, url: str) -&gt; dict:\n\"\"\"Convert the yaml file in the repository to a dict.\"\"\"\nif details_resp := gh.fetch(f\"{url}/{DETAILS_FILE}\"):\nreturn yaml.safe_load(details_resp.content)\nraise Exception(f\"Could not get details from {url=}\")\n@classmethod\ndef from_url(cls, url: str, set_img: bool = False):\n\"\"\"Each member url can be converted to a fully validated object\n        via a valid Github `url`; if `set_img` is set to true,\n        an `img_id` is created on Cloudflare.\"\"\"\nobj = MemberURL.setter(url, set_img)\nreturn cls(\n**cls.extract_details(obj.target_url),\nid=obj.id,\nimg_id=obj.img_id,\ncreated=datetime.datetime.now().timestamp(),\nmodified=datetime.datetime.now().timestamp(),\n)\n</code></pre>"},{"location":"#corpus_pax.resources.RegisteredMember-functions","title":"Functions","text":""},{"location":"#corpus_pax.resources.RegisteredMember.extract_details","title":"<code>extract_details(url)</code>  <code>classmethod</code>","text":"<p>Convert the yaml file in the repository to a dict.</p> Source code in <code>corpus_pax/resources.py</code> Python<pre><code>@classmethod\ndef extract_details(cls, url: str) -&gt; dict:\n\"\"\"Convert the yaml file in the repository to a dict.\"\"\"\nif details_resp := gh.fetch(f\"{url}/{DETAILS_FILE}\"):\nreturn yaml.safe_load(details_resp.content)\nraise Exception(f\"Could not get details from {url=}\")\n</code></pre>"},{"location":"#corpus_pax.resources.RegisteredMember.from_url","title":"<code>from_url(url, set_img=False)</code>  <code>classmethod</code>","text":"<p>Each member url can be converted to a fully validated object via a valid Github <code>url</code>; if <code>set_img</code> is set to true, an <code>img_id</code> is created on Cloudflare.</p> Source code in <code>corpus_pax/resources.py</code> Python<pre><code>@classmethod\ndef from_url(cls, url: str, set_img: bool = False):\n\"\"\"Each member url can be converted to a fully validated object\n    via a valid Github `url`; if `set_img` is set to true,\n    an `img_id` is created on Cloudflare.\"\"\"\nobj = MemberURL.setter(url, set_img)\nreturn cls(\n**cls.extract_details(obj.target_url),\nid=obj.id,\nimg_id=obj.img_id,\ncreated=datetime.datetime.now().timestamp(),\nmodified=datetime.datetime.now().timestamp(),\n)\n</code></pre>"},{"location":"#individual","title":"Individual","text":"<p>         Bases: <code>RegisteredMember</code>, <code>IndividualBio</code>, <code>TableConfig</code></p> Source code in <code>corpus_pax/entities.py</code> Python<pre><code>class Individual(RegisteredMember, IndividualBio, TableConfig):\n__prefix__ = \"pax\"\n__tablename__ = \"individuals\"\n@validator(\"id\", pre=True)\ndef lower_cased_id(cls, v):\nreturn v.lower()\nclass Config:\nuse_enum_values = True\n@classmethod\ndef list_members_repo(cls):\nreturn gh.fetch_entities(\"members\")\n@classmethod\ndef make_or_replace(\ncls,\nc: Connection,\nurl: str,\nreplace_img: bool = False,\n):\nindiv_data = cls.from_url(url, replace_img)\ntbl = c.table(cls)\nrow = tbl.insert(indiv_data.dict(), replace=True, pk=\"id\")  # type: ignore # noqa: E501\nif pk := row.last_pk:\nif indiv_data.areas:\nPracticeArea.associate(tbl, pk, indiv_data.areas)\nif indiv_data.categories:\nPersonCategory.associate(tbl, pk, indiv_data.categories)\n</code></pre>"},{"location":"#org","title":"Org","text":"<p>         Bases: <code>RegisteredMember</code>, <code>TableConfig</code></p> Source code in <code>corpus_pax/entities.py</code> Python<pre><code>class Org(RegisteredMember, TableConfig):\n__prefix__ = \"pax\"\n__tablename__ = \"orgs\"\nofficial_name: str = Field(None, max_length=100, col=str, fts=True)\n@classmethod\ndef list_orgs_repo(cls):\nreturn gh.fetch_entities(\"orgs\")\ndef set_membership_rows(self, c: Connection) -&gt; Table | None:\nmember_list = []\nif self.members:\nfor member in self.members:\nemail = member.pop(\"account_email\", None)\nif email and (acct := EmailStr(email)):\nobj = OrgMember(\norg_id=self.id,\nindividual_id=None,\nrank=member.get(\"rank\", 10),\nrole=member.get(\"role\", \"Unspecified\"),\naccount_email=acct,\n)\nmember_list.append(obj)\nif member_list:\nreturn c.add_cleaned_records(OrgMember, member_list)\nreturn None\n@classmethod\ndef make_or_replace(\ncls,\nc: Connection,\nurl: str,\nreplace_img: bool = False,\n):\norg_data = cls.from_url(url, replace_img)\ntbl = c.table(cls)\nrow = tbl.insert(org_data.dict(), replace=True, pk=\"id\")  # type: ignore # noqa: E501\nif pk := row.last_pk:\nif org_data.areas:\nPracticeArea.associate(tbl, pk, org_data.areas)\nif org_data.categories:\nPersonCategory.associate(tbl, pk, org_data.categories)\norg_data.set_membership_rows(c)\n</code></pre>"}]}